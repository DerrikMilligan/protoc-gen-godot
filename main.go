package main

import (
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}

			generateFile(gen, f)
		}
		return nil
	})
}

func getGodotFieldType(field *protogen.Field) string {
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind,
		protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind,
		protoreflect.Uint32Kind, protoreflect.Fixed32Kind,
		protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		return "int"
	case protoreflect.FloatKind, protoreflect.DoubleKind:
		return "float"
	case protoreflect.StringKind:
		return "String"
	case protoreflect.BytesKind:
		return "PoolByteArray"
	case protoreflect.MessageKind:
		return string(field.Desc.Message().FullName().Name())
	// Maybe this would be handled differently?
	case protoreflect.EnumKind:
		return string(field.Desc.Enum().FullName().Name())
		// return "int"
	}
	return "Unknown " + field.Desc.Kind().String()
}

func getGodotDefaultValue(field *protogen.Field) string {
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		return "false"
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		return "0"
	case protoreflect.FloatKind:
	case protoreflect.DoubleKind:
		return "0.0"
	case protoreflect.StringKind:
		return "\"\""
	case protoreflect.BytesKind:
		return "PackedByteArray()"
	case protoreflect.MessageKind:
		return "null"
	// Maybe this would be handled differently?
	case protoreflect.EnumKind:
		return "0"
	}
	return "null"
}

// generateFile generates a _ascii.pb.go file containing gRPC service definitions.
func generateFile(gen *protogen.Plugin, file *protogen.File) {
	filename := file.GeneratedFilenamePrefix + "_pb.gd"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("# @generated by protoc-gen-godot")
	g.P("# @generated from ", file.Desc.Path())
	g.P("#")
	g.P("# Proto syntax: ", file.Desc.Syntax())
	if file.Proto.Edition != nil {
		g.P("# Edition: ", file.Proto.Edition)
	}
	g.P()
	g.P("const proto3 = preload(\"proto3.gd\")")
	g.P()

	// Generate the enum definitions
	for _, enum := range file.Enums {
		g.P("# @generated from enum ", enum.Desc.Name())
		g.P("enum ", enum.GoIdent.GoName, " {")
		for _, value := range enum.Values {
			g.P("\t# @generated from enum value: ", value.Desc.Name(), " = ", value.Desc.Number())
			g.P("\t", value.Desc.Name(), " = ", value.Desc.Number(), ",")
			// Potentially in the future have some section like this if needed?

			// // Retrieve enum metadata with: proto3.getEnumType(GameType)
			// proto3.util.setEnumType(GameType, "GameType", [
			// 	{ no: 0, name: "GO_ALREADY" },
			// ]);
		}
		g.P("}")
		g.P()
		g.P()
	}

	// Generate Message definitions
	for _, msg := range file.Messages {
		g.P("# @generated from message ", msg.Desc.Name())
		g.P("class ", msg.GoIdent.GoName, " extends proto3.Message:")
		for _, field := range msg.Fields {
			g.P("\t# @generated from field: ", field.Desc.Kind().String(), " ", field.Desc.Name(), " = ", field.Desc.Number())
			g.P("\tvar ", field.Desc.Name(), " = null  # Type: ", getGodotFieldType(field))
			g.P()
		}
		g.P()
		g.P()
	}

	// return g
}
